# Hotkey与Bigkey的优化

## 常见的HotKey

从访问量上来说，常见的HotKey:

- 某Redis实例的每秒总访问量为10000,而其中一个key的每秒访问量达到了7000(访问次数显著高于其它key)

- 对一个拥有上千成员且总大小为1M的hash key每秒发送大量的hgetall(带宽占用显著高于其它key)

- 对一个拥有上万成员的zset key每秒发送大量的zrange(cpu时间占用显著高于其它key)

从业务场景来看，常见的case:

- 热门数据：比如电商平台的一些爆款商品详情页，社交平台的热门帖子等，往往会被大量用户频繁访问，从而形成热点key

- 短时高并发：例如新闻网站上的突发新闻，秒杀活动中的商品信息等。这些key的访问量在短时间内剧增，容易形成热点

- 请求分片集中：在redis集群中，某些固定名称的key可能通过哈希分片集中到同一个节点。当这些key访问量突增时，该节点达到性能瓶颈，导致热点key问题。

## HotKey引发的问题

- CPU资源过载：如果某个key被频繁访问，处理这些请求的redis实例可能出现cpu过载的情况，导致处理其他请求的能力下降，影响整体性能

- 内存资源紧张：热点key会占用redis实例大量内存资源，如果key本身的数据量较大，可能导致内存紧张，影响redis正常运行

- 负载不均衡：在redis集群中，热点key可能集中在某个或某几个节点上，导致这些节点的负载远高于其他节点。这种不均衡会导致集群的整体性能下降

- 主从同步延迟：如果redis处于主从模式，热点key的频繁访问会导致主节点压力增加，进而导致主从同步延迟，产生数据不一致风险。这种情况在高并发场景下尤为明显

- 缓存击穿：当一个热点key的缓存失效后，大量请求直接穿透redis打到后端数据库，造成瞬时请求风暴，特别影响后端服务的性能，甚至引发后端服务崩溃

## HotKey的监测

- Monitor命令：可以实时监控redis服务器执行的所有命令。通过这些命令，可以观察到哪些key被频繁访问，识别出热点key。不过，monitor命令开销较大，一般只在调试阶段使用。

- Lua脚本：可以编写lua脚本或使用redis的命令组合(如scan ttl等)定期统计和记录访问频率高的key

- Redis分析工具：在redis4.0及以上版本中，redis-cli提供了--hotkeys选项，可以帮助分析哪些key是热点key

- Redis监控工具：第三方监控工具(如RedisInsight Prometheus等)可以实时监控redis实例的性能数据，并通过设置监控指标和告警，自动检测出访问频率高的key

- Slowlog命令：slowlog可以记录执行时间较长的命令，尽管它主要用于监控慢查询，但如果某个key的操作频繁导致命令变慢，也可以通过此方法来发现热点key

## HotKey的优化

- 使用本地缓存：在应用层使用本地缓存(如Guava Cache Ehcache等)来减轻redis的负担。当热key请求到达时，优先查询本地缓存，减轻redis服务压力。

- 数据分片：将热key数据分散存储到不同的redis节点或分片中。如使用redis cluster将数据分布到多个节点上。这样可以分散负载，减轻单节点压力。

- 读写分离：对于读多写少的热key，可以采用读写分离的架构。设置一个或多个从节点负责读流量处理，主节点负责写流量处理。显著提高读操作性能。

- 热key预热：在系统启动或流量高峰前，预先将热点key加载到redis中，减少高峰期的访问延迟。可以通过定时任务和缓存预热工具实现。

- 限流和降级：使用限流策略来限制对热key的访问频率。当系统面临高负载时，可以实施降级策略，如返回部分数据来减少对热key的依赖

- 监控调优：定期巡检redis的性能指标(如cpu使用率，内存使用情况，慢查询日志等)，根据监测结果进行调优。包括调整配置参数，优化数据结构和增加硬件资源等。

## Bigkey定义

大key具体表现redis中的key对应的value很大，本质上是大value问题。对于redis中不同的数据类型，常见Bigkey如下：

- 对于String类型的value值，值超过10MB(数据值太大)

- 对于List类型的value值，含有的成员数量超过10000个(成员数量过多)

- 对于Hash格式的value值，含有的成员数量超过1000个或成员变量value值大小超过10MB(成员总体积过大)

- 对于Set类型的value值，含有的成员数量超过10000个(成员数量过多)

在redis实际应用中，大key问题的定义和评判标准并非固定不变，而是需要结合具体业务场景和性能需求进行综合考量。

在高并发，低延迟的敏感场景下，即使10KB的数据也可能被视为大key，而在低并发，高吞吐的离线处理环境中，大key的阈值可能放宽至100KB甚至更高。

因此，在redis的设计与使用过程中，应基于业务特性和性能指标来制定合理的大key评估标准。

## Bigkey的来源

大key是如何产生的？

- 错误的技术选型：比如使用String类型的key存放大体积二进制文件型数据，从而造成key对应的value值特别大。

- List和Set数据未清理：比如使用redis List作为消息队列，在实际应用中生产者发送消息过快，消费者消费消息速度慢，导致消息堆积

- 数据没有合理分片：业务上线前，对业务分析不准确，没有对key中成员进行合理拆分，造成个别key成员数量过多。

大key如何探测？

执行redis-cli命令时带上-bigkeys选项，对整个数据库中的键值对大小情况进行统计分析，统计每种数据类型的键值对个数及平均大小。(bigkeys是通过扫描数据库来查找的，在执行过程中，会对redis实例性能产生影响)在执行这个命令后，会输出每种数据类型中最大的bigkey信息：

- 对于String类型来说，会输出最大bigkey的字节长度

- 对于集合类型来说，会输出最大bigkey的元素个数

- 主从集群，建议在从节点上执行该命令，避免阻塞主节点

- 没有从节点情况下，在redis实例业务压力低峰阶段进行扫描查询，以免影响实例正常运行

## Bigkey的影响

- 内存不均匀：在redis集群架构中，某个数据分片的内存使用率远超其他数据分片，内存资源无法达到平衡。

- 线程阻塞：redis是单线程架构，操作大key耗时较长，会造成请求阻塞

- 网络拥塞：如果一个大key占用空间1MB，每秒访问1000次，就有1000MB流量，可能造成实例或网络带宽被占满，影响服务性能

- 持久化变慢：AOF与RDB都会因为大key耗费更多时间，大key会导致AOF重写和RDB创建变慢。

## Bigkey问题优化

- 清理无效数据：主要针对list和set两种数据类型，在使用过程中，如果list和set中内容不断增加，要定时清理。

- 压缩大key的value：通过序列化或者压缩的方式对value进行压缩，使其变为较小的value。

- 针对大key进行拆分：通过将bigkey拆分成多个小key的键值对，然后进行存储。在读取时，通过get不同key或mget批量获取存储键值对

- 实时监控redis cpu，内存，带宽和key增长趋势：通过监控系统，监控redis中的内存占用大小和网络带宽占用大小，以及固定时间的内存占用增长率，超过设定的阈值时，设置告警。